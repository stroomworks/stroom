package stroom.dashboard.impl.visualisation;

import stroom.event.logging.rs.api.AutoLogged;
import stroom.util.logging.LambdaLogger;
import stroom.util.logging.LambdaLoggerFactory;
import stroom.visualisation.shared.VisualisationAssetResource;
import stroom.visualisation.shared.VisualisationAssetUpdateContent;
import stroom.visualisation.shared.VisualisationAssetUpdateDelete;
import stroom.visualisation.shared.VisualisationAssetUpdateNewFile;
import stroom.visualisation.shared.VisualisationAssetUpdateRename;
import stroom.visualisation.shared.VisualisationAssets;

import jakarta.inject.Inject;
import jakarta.inject.Provider;

import java.io.IOException;

import static stroom.event.logging.rs.api.AutoLogged.OperationType.UNLOGGED;

/**
 * Serverside REST handling for Visualisation Assets.
 * <br>TODO Perform audit logging
 */
@AutoLogged(UNLOGGED)
public class VisualisationAssetResourceImpl implements VisualisationAssetResource {

    private static final LambdaLogger LOGGER = LambdaLoggerFactory.getLogger(VisualisationAssetResourceImpl.class);

    /** Service that backs the resource */
    private final Provider<VisualisationAssetService> serviceProvider;

    @SuppressWarnings("unused")
    @Inject
    VisualisationAssetResourceImpl(final Provider<VisualisationAssetService> serviceProvider) {
        this.serviceProvider = serviceProvider;
    }

    @Override
    public VisualisationAssets fetchDraftAssets(final String ownerId) throws RuntimeException {
        LOGGER.info("ResourceImpl: fetchAssets with ownerId {}", ownerId);
        try {
            return serviceProvider.get().fetchDraftAssets(ownerId);
        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in fetchDraftAssets: {}", t.getMessage(), t);
            throw t;
        }
    }

    @Override
    public Boolean updateNewFolder(final String ownerDocId, final String path)
            throws RuntimeException {

        LOGGER.info("updateNewFolder: {}", path);
        try {
            serviceProvider.get().updateNewFolder(ownerDocId, path);
        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in updateNewFolder: {}", t.getMessage(), t);
            throw t;
        }

        return Boolean.TRUE;
    }

    @Override
    public Boolean updateNewFile(final String ownerDocId, final VisualisationAssetUpdateNewFile update)
            throws RuntimeException {
        LOGGER.info("updateNewFile: {}", update.getPath());
        try {
            serviceProvider.get().updateNewFile(ownerDocId, update.getPath());
        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in updateNewFile: {}", t.getMessage(), t);
            throw t;
        }

        return Boolean.TRUE;
    }

    @Override
    public Boolean updateNewUploadedFile(final String ownerDocId,
                                         final VisualisationAssetUpdateNewFile update)
            throws RuntimeException {
        LOGGER.info("updateNewUploadedFile: {}", update.getPath());
        try {
            serviceProvider.get().updateNewUploadedFile(
                    ownerDocId,
                    update.getPath(),
                    update.getResourceKey());

        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in updateNewUploadedFile: {}", t.getMessage(), t);
            throw t;
        }

        return Boolean.TRUE;
    }

    @Override
    public Boolean updateDelete(final String ownerDocId, final VisualisationAssetUpdateDelete update)
            throws RuntimeException {
        LOGGER.info("updateDelete: {}", update.getPath());
        try {
            serviceProvider.get().updateDelete(ownerDocId, update.getPath(), update.isFolder());
        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in updateDelete: {}", t.getMessage(), t);
            throw t;
        }

        return Boolean.TRUE;
    }

    @Override
    public Boolean updateRename(final String ownerDocId,
                                final VisualisationAssetUpdateRename update)
            throws RuntimeException {
        LOGGER.info("updateRename: '{}' -> '{}'", update.getOldPath(), update.getNewPath());
        try {
            serviceProvider.get().updateRename(
                    ownerDocId,
                    update.getOldPath(),
                    update.getNewPath(),
                    update.isFolder());
        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in updateRename: {}", t.getMessage(), t);
            throw t;
        }

        return Boolean.TRUE;
    }

    @Override
    public Boolean updateContent(final String ownerDocId,
                                 final VisualisationAssetUpdateContent update)
            throws RuntimeException {
        LOGGER.info("updateContent: {}", update.getPath());
        try {
            serviceProvider.get().updateContent(ownerDocId, update.getPath(), update.getContent());
        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in updateContent: {}", t.getMessage(), t);
            throw t;
        }

        return Boolean.TRUE;
    }

    @Override
    public Boolean saveDraftToLive(final String ownerDocId) throws RuntimeException {
        try {
            serviceProvider.get().saveDraftToLive(ownerDocId);
        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in saveDraftToLive: {}", t.getMessage(), t);
            throw t;
        }
        return Boolean.TRUE;
    }

    @Override
    public Boolean revertDraftFromLive(final String ownerDocId) throws RuntimeException {
        try {
            serviceProvider.get().revertDraftFromLive(ownerDocId);
        } catch (final IOException e) {
            throw new RuntimeException(e);
        } catch (final Throwable t) {
            LOGGER.error("Error in revertDraftFromLive: {}", t.getMessage(), t);
            throw t;
        }
        return Boolean.TRUE;
    }
}
